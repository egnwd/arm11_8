Intro to extension ------------------------
Our extension consists of advancements to our assembly language, a binary counter and an implementation of a photo gate. Improving the assembler will allow us to make easier to read code and utilise method calls more easily.

We added the ability to create comments alongside instructions which has proved to be a useful feature. Comments are started by typing a semi-colon where the comment starts. Comments can be placed either on an empty line or at the end of an instruction. For each of these two possibilities there are 3 types of comments that our program distinguishes between: A blank comment with no text (e.g. “;”), a comment with no spaces at the start (e.g. “;comment”),  a comment with spaces after the start (e.g. “;   comment”).

We have also implemented a stack that will be used to push and pop the PC. As the PC contains the address of the current instruction, if we want to enter a method using a new address we have to alter the PC which will overwrite its contents. Hence to overcome this problem, we have improved the “mov” instruction in the emulator to allow the PC to be stored in a chosen address. Special conditions for moving the PC was added to ensure the program adhered to the pipeline system.  Moving the PC is essentially pushing it on to our stack, its contents will be the return address of a method call. When we need to return, we use a series of instructions to pop the PC (store the return address back into the PC so we can leave the method) [ELYAS].

The extension also includes operations that allows us to create a photo gate using an IR LED and photo transistor. The phototransistor registers infrared light that is produced by the LED that is directed at it. Our program is able to register a steady detection when the photo gate is stationary and undisturbed. Once an object is passed between the LED and the phototransistor, a signal is sent through the Raspberry Pi which then registers that the light between the LED and phototransistor has been broken. [To allow us to easily manage the testing of the detection, an Extra LED is added to the Raspberry Pi. It will only turn on when the light between the LED and transistor is broken. So we can quickly determine if our program detects changes within the photo gate by observing this status LED]. This photo gate can be used for a variety of applications such as an alarm system, speed detection (when used with a timer) and simple games that require objects (such as small balls) to reach a certain point.
Design---------------------
To implement the adjusted PC move operation, we added an if statement to determine if the PC was selected. If so we had the instruction behave as a branch after the move operation was executed. [ASK ELYAS] this means that the extra instruction currently being fetched in the pipe line will be ignored. This is because altering the PC is essentially jumping to the address of a new method.

Our Raspberry Pi can also operate a 3 bit binary counter that counts from 0 to 7. There are 3 LEDs that are connected to the Raspberry Pi which represent the bit pattern (I.e. If the LED is on it is representing a 1). Once the program counts to 7 the Raspberry Pi will restart the program to count from 0.  The three LEDs were connected to three consecutive pins (2, 3 and 4). We set the pins to output then initialised them by clearing them. A while loop was used to increment a count (which starts at 0 and stored in a register). The output of the LEDs depend on the contents of count.

GPIO emulator implementation part 3 --------------------------

We added constants that contain the GPIO set/clear area addresses that will be used to alter their outputs. Three more constants were made to contain the GPIO status addresses that modify the state of each pin.  Memory was allocated for all five of the addresses. The emulator had to be updated to allow these addresses to be modify. This was done by adding functionality to the functions that access memory locations. If these special memory address are being accessed (e.g. 0x2020 0004) then our program alters their respective memory locations rather than the allocated RAM memory used to store the instructions.

Testing + effectiveness -------------------------------
Conclusion ----------------------

YOOO
