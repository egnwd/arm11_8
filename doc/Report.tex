\documentclass[11pt]{article}
\usepackage{float}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[margin=0.8in]{geometry}
\usepackage{listings}
\usepackage{framed}
\lstset{
	language=C,
	basicstyle=\scriptsize\ttfamily,
	commentstyle=\ttfamily\color{green},
	numbers=left,
	numberstyle=\ttfamily\color{blue}\footnotesize,
	stepnumber=1,
	numbersep=5pt,
	backgroundcolor=\color{white},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	frame=single,
	tabsize=2,
	captionpos=b,
	breaklines=true,
	breakatwhitespace=false,
	title=\lstname,
	escapeinside={},
	keywordstyle={},
	morekeywords={}
}

\setcounter{secnumdepth}{0}

\begin{document}

\title{Report: ARM11 Project \\ Group 8}
\author{Elliot Grenwood, Elyas Addo, Florian Emile, Nana Asiedu-Ampem}

\maketitle

\section{Introduction}
This report covers the completion of Group 8's ARM11 Project, specifically Parts II - IV: Assembler; General Purpose Input/Output on a Raspberry Pi; our chosen extension. The assembler program, like the emulator, is written in C. Part of the extension is also written in C, and the other part in the ARM11 assembly language. In this report we will also discuss the organisation and communication of the group.

\section{Part II - Assembler}

Our assembler can be split into 5 subtasks:\newline

- input/output setup with \verb|setUpIO()| in \texttt{assemble.c} which simply sets the pointer
to the input and output files.\newline

- breaking up the input file with \verb|tokenise()| in \texttt{tokenise.c}; an array of tokens is created where a token is composed of two fields - the original string and the token type (e.g. LABEL).\newline

- parsing in the input file with \verb|parseProgram()| in \texttt{parse.c}. Since different instructions require different components (flags, arguments, e.t.c.), parse functions have been written to cater for all instruction types. Each parse function computes the arguments to pass in the generate functions (below) by accessing the symbol tables that links the "word" to the matching number and by
computing the flags that are set.\newline 

- generating the instruction in binary for each type of opcode using generate
functions (different for every type of opcode) all in \texttt{generate.c.}\newline

- writing the binary instruction to the output file using \verb|ouputData()| in \texttt{assemble.c}.\newline

Using assembly files in a provided testsuite, the \texttt{./assemble} outputs were compared to the expected outputs to ensure the program function correctly.
\section{Part III - GPIO}
%nana for emulate, no change for assembler, testing - flashes\newline

We added constants that contain the GPIO set/clear area addresses that will be used to alter their outputs. Three more constants were made to contain the GPIO status addresses that modify the state of each pin.  Memory was allocated for all five of the addresses. The emulator had to be updated to allow these addresses to be modify. This was done by adding functionality to the functions that access memory locations. If these special memory address are being accessed (e.g. 0x2020 0004) then our program alters their respective memory locations rather than the allocated RAM memory used to store the instructions.

\section{Part IV - Extension}
Our chosen extension has 4 parts: allowing the use of comments in an assembler file being passed into our assembly program; creating a 3 bit binary counter in assembly language; changing the functionality of \texttt{mov r15, r14} to allow returns from function calls; creating a IR-based counter. \newline 

  \noindent all have description, design, problems, testing
  
\subsection{Comments}
The ability to write comments alongside instructions is a useful feature. It can improve the clarity of assembly code which allows for easier maintainance. Comments begin with a semi-colon and finish at the end of the line. They can be placed either on an empty line or at the end of an instruction. For a new-line and end-of-line comments there are 3 types to test for: a blank comment with no text (e.g. \texttt{;}), a comment with no spaces at the start (e.g. \texttt{;comment}), a comment with spaces after the start (e.g. \texttt{; comment}).\newline

\noindent Since comments only exist in an assembly file, only the assembler program had to be edited. The \verb|tokenise()| function was amended to check for a \texttt{;} at the beginning of a token, and if one is found, start reading the next line. Although the comment update was implemented by a member of the group who didn't work on the tokeniser, change was easily made due to the clarity of the original design.\newline

\noindent Figure 1 below shows the \texttt{./emulate} output for the \texttt{commentTest} program assembled with and without the comments. We also used our assembler on the original test suite to ensure the feature didn't affect any other element of the program.
\lstinputlisting{commentTest.s}

\begin{figure}[H]
	\centering
	\includegraphics[scale = 0.5]{commentTest}
	\caption{Abhinav Gandhi taught me how to do this}
\end{figure}

\subsection{3 Bit Binary Counter}
\subsection{Implementing \texttt{mov r15, rn}}
In order to use functions, a program can create its own stack structure in memory. This allows the program to store the derived return address and then branch to a function. However, in order to return from a function the PC must store the return address whilst maintaining the pipeline effect. The ARM11 architecture already has a \texttt{mov PC, rn} command which braches automatically so \texttt{./assemble} needs no changing. However, to test the function we have improved the \texttt{mov} instruction in the emulator to allow the PC to store in a chosen address and then branch immediately. again this was very little challenge as it simply involved a small if statement.
\subsection{IR-Based Counter}

  - all have description, design, problems, testing

\section{Reflection of working in a group}
\subsection{Elliot Greenwood}
\subsection{Elyas Addo}
\subsection{Florian Emile}

I thought that the most challenging part of the project would have been writing
in assembly. However coding the assembler in C was the trickiest as C was new to
me and the tasks in assembly were straightforward. I had to get used to drawing
flowcharts and writing pseudo codes for part II as it made my task easier.

I found my programming skills were not on par with those of my team members. I
verified if I understood the concepts before coding. I kept my team leader
informed of my progress as I made it easier for him to help me. When I was
working on a task with someone, I was always open to his suggestions since we
can find what we think is the best solution faster.

In a different team, I would keep my team (especially team leader) informed of
my progress in the task at hand I would also like to be more independent when I
am assigned an individual task.

\subsection{Nana Asiedu-Ampem}
\subsection{Group Reflection}

\section{Introduction}

Our extension consists of advancements to our assembly language, a binary counter and an implementation of a photo gate. Improving the assembler will allow us to make easier to read code and utilise method calls more easily.\newline

\noindent We have also implemented a stack that will be used to push and pop the PC. As the PC contains the address of the current instruction, if we want to enter a method using a new address we have to alter the PC which will overwrite its contents. Hence to overcome this problem, we have improved the \texttt{mov} instruction in the emulator to allow the PC to be stored in a chosen address. Special conditions for moving the PC was added to ensure the program adhered to the pipeline system.  Moving the PC is essentially pushing it on to our stack, its contents will be the return address of a method call. When we need to return, we use a series of instructions to pop the PC (store the return address back into the PC so we can leave the method) [ELYAS].\newline

\noindent Our program also includes a binary counter which is displayed using a series of LEDs that represents a bit pattern. [ASK]\newline

\noindent The extension also includes operations that allows us to create a photo gate using an IR LED and photo transistor. The phototransistor registers infrared light that is produced by the LED that is directed at it. Our program is able to register a steady detection when the photo gate is stationary and undisturbed. Once an object is passed between the LED and the phototransistor, a signal is sent through the Raspberry Pi which then registers that the light between the LED and phototransistor has been broken. [To allow us to easily manage the testing of the detection, an Extra LED is added to the Raspberry Pi. It will only turn on when the light between the LED and transistor is broken. So we can quickly determine if our program detects changes within the photo gate by observing this status LED]. This photo gate can be used for a variety of applications such as an alarm system, speed detection (when used with a timer) and simple games that require objects (such as small balls) to reach a certain point.

\section{Design}
To implement the adjusted PC move operation, we added an if statement to determine if the PC was selected. If so we had the instruction behave as a branch after the move operation was executed. [ASK ELYAS] this means that the extra instruction currently being fetched in the pipe line will be ignored. This is because altering the PC is essentially jumping to the address of a new method.

\section{Testing + effectiveness}

\section{Conclusion}

\end{document}
